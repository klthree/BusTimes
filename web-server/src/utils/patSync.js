const fs = require('fs');
const haversine = require('haversine');
const bus_routes = require('./pat');
const stops = require('../data/allStops.json');

const pathFinder = (origin, destination) => {
    let originStops = closest(origin, stops, );
}

/** Determines whether two routes can be considered adjacent
    to one another. Two routes are considered adjacent if they
    have stops that are within a specified distance of one another.
*/
const adjacency = (routeA, routeB) => {
    // if adjacent, return the stops
    // if not, return null
    let acceptable_dist = 0.1;
    const stopOptions = [];

    routeA.dir.forEach(directionA => {
        routeA[directionA.id].forEach(stopA => {
            routeB.dir.forEach(directionB => {
                routeB[directionB.id].forEach(stopB => {
                    let actual_dist = haversine({latitude: stopA.lat, longitude: stopA.lon},
                        {latitude: stopB.lat, longitude: stopB.lon}, {unit:'miles'})
                    if((actual_dist) <= acceptable_dist) {
                        stopOptions.push([routeA.rt, stopA, routeB.rt, stopB, actual_dist]);
                    }
                })
            })
        })
    })

    if(stopOptions.length != 0) {
        return stopOptions;
    } else {
        return null;
    }
}

// Generates an object of all routes and adds directions and lists of available stops.
// Result is keyed by route number and written to file './web-server/src/data/routes_and_stops.json'
const route_and_stop_grabber = async () => {
    loc = "";
    let x = await bus_routes.get_routes(loc)
        .then((response) => bus_routes.get_dir(response))
        .then((response) => bus_routes.get_route_stops(response));
    
    const newStops = flatDeep(x, Infinity);
    const allRoutes = newStops.reduce((acc, curr) => {
        if(!(curr.rt in acc)) {
            acc[curr.rt] = curr
        }

        return acc;
    }, {})

    all_stop_grabber(await allRoutes);
    fs.writeFileSync("./web-server/src/data/routes_and_stops.json", JSON.stringify(allRoutes), 'utf8', () => {});
}

// Takes object generated by route_and_stop_grabber and writes all unique stops to file
// './web-server/src/data/stops.json'
const all_stop_grabber = (allRoutes) => {
    const totalStops = [];

    Object.values(allRoutes).forEach(element => element.dir.forEach(direction => {
        totalStops.push(element[direction.id]);
    }));

    const totStops = flatDeep(totalStops, Infinity);
    const allStops = totStops.reduce((acc, curr) => {
        if(acc.filter((element) => element.stpid === curr.stpid).length === 0) {
            acc.push(curr);
        }
        return acc;
    }, []);

    console.log("Total stops = " + allStops.length);
    fs.writeFileSync("./web-server/src/data/allStops.json", JSON.stringify(allStops), 'utf8', () => {});
}

const closest_stops = (start, stoplist, top) => {
    stoplist.sort((stopA, stopB) => {
        return haversine(start, {latitude: stopA.lat, longitude: stopA.lon})
            - haversine(start, {latitude: stopB.lat, longitude: stopB.lon})
    })
    
    let walking_distance = haversine(start, {latitude: stoplist[0].lat, longitude: stoplist[0].lon}, {unit: 'mile'})

    return {walking_distance: walking_distance, sorted_stops: stoplist.slice(0, top)};
}

// This function changes nested arrays to a one dimensional array
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
function flatDeep(arr, d = 1) {
    return d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])
                 : arr.slice();
};

module.exports = {
    closest_stops,
    route_and_stop_grabber,
    all_stop_grabber,
    adjacency
}